#!/usr/local/bin/bpftrace
#include <asm-generic/errno.h>
#include <linux/in.h>
#include <net/tcp_states.h>
#include <net/sock.h>
#include <net/inet_sock.h>
#include <linux/socket.h>

BEGIN
{
    printf("Tracing IP TCP connect latency and SYN retry with stacks. Ctrl-C to end.\n");

    @tcp_states[1] = "ESTABLISHED";
    @tcp_states[2] = "SYN_SENT";
    @tcp_states[3] = "SYN_RECV";
    @tcp_states[4] = "FIN_WAIT1";
    @tcp_states[5] = "FIN_WAIT2";
    @tcp_states[6] = "TIME_WAIT";
    @tcp_states[7] = "CLOSE";
    @tcp_states[8] = "CLOSE_WAIT";
    @tcp_states[9] = "LAST_ACK";
    @tcp_states[10] = "LISTEN";
    @tcp_states[11] = "CLOSING";
    @tcp_states[12] = "NEW_SYN_RECV";    
}

kprobe:tcp_connect
{
    $sk = (struct sock *)arg0;
    $inet = (struct inet_sock *)arg0;

    @sk2connectUS[$sk] = nsecs;
}



kprobe:inet_sk_state_store
{
    $sk = (struct sock *)arg0;
    $inet = (struct inet_sock *)arg0;
    $newstate = arg1;
    if( $newstate == TCP_CLOSE ) {
        if( $sk->__sk_common.skc_state == TCP_SYN_SENT && @sk2connectUS[$sk] ) {

            $dport = $sk->__sk_common.skc_dport;
            $dport = ($dport >> 8) | (($dport << 8) & 0x00FF00);

            $sport = $inet->inet_sport;
            $sport = ($sport >> 8) | (($sport << 8) & 0x00FF00);

            $sk_family = $sk->__sk_common.skc_family;


            time("%H:%M:%S ");
            printf("TCP_SYN_SENT to CLOSE: %-6d %-16s %d ms %-3d ", 
                pid, comm, (nsecs - @sk2connectUS[$sk])/1000000,
                $sk_family == AF_INET ? 4 : 6);
            printf("%-15s:%-5d  -->  %-15s:%-5d\n", ntop($sk_family , $inet->inet_saddr), $sport,
                ntop($sk_family, $sk->__sk_common.skc_daddr), $dport);
            printf("kstack: %s\n", kstack);
            printf("ustack: %s\n", ustack);
        }
        else {

        }
        delete(@sk2connectUS[$sk]);
    }

}

kprobe:tcp_retransmit_skb
{
    $sk = (struct sock *)arg0;
    $inet_family = $sk->__sk_common.skc_family;
    if ($inet_family == AF_INET || $inet_family == AF_INET6)
    {
        $state = $sk->__sk_common.skc_state;
        if( $state == 2/*SYN_SENT*/ ) {
            $daddr = ntop(0);
            $saddr = ntop(0);
            if ($inet_family == AF_INET)
            {
                $daddr = ntop($sk->__sk_common.skc_daddr);
                $saddr = ntop($sk->__sk_common.skc_rcv_saddr);
            }
            else
            {
                $daddr = ntop(
                    $sk->__sk_common.skc_v6_daddr.in6_u.u6_addr8);
                $saddr = ntop(
                    $sk->__sk_common.skc_v6_rcv_saddr.in6_u.u6_addr8);
            }
            $lport = $sk->__sk_common.skc_num;
            $dport = $sk->__sk_common.skc_dport;
            // Destination port is big endian, it must be flipped
            $dport = ($dport >> 8) | (($dport << 8) & 0x00FF00);
            $statestr = @tcp_states[$state];
            time("%H:%M:%S ");
            printf("%-8d %14s:%-6d %14s:%-6d %6s\n", pid, $saddr, $lport,
                $daddr, $dport, $statestr);
        }
    }
}


END
{
    clear(@tcp_states);
}